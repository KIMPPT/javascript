소수 : 1과 자기자신을 제외한 사이의 어떤 수로 나누어 떨어지지 않음
        for (let i = 2; i < 100; i++)
        {
            for (let j = 1; j < i; j) //자기자신까지 검사하는 구간
            {
                j++; //1은 모든 숫자의 약수이므로 2부터 시작해야함
                if (j == i) //나누는 숫자가 자기자신일때까지 약수가 없으면 소수확정
                {
                    document.write(`${i}는 소수입니다<br>`);
                }
                else //나누는 숫자가 자기자신으로 가기 전까지 숫자 반복
                {
                    if (i % j != 0) continue; //나누어 떨어지지 않으면 다음숫자로 나누기 시작[2번째 for문 으로 다시 시작]
                    else break; //중간에 약수가 있다면 바로 벗어남[2번째 for문에서 벗어남]
                }
            }
        }
성질
1. 1부터 자기자신의 반까지만 확인해도 된다.
이유는 반을 넘어서게 되면 1.xx가 된다. 즉, 반 이후부터는 절대로 약수가 될 수 없다
2. 1.의 범위를 더 확장시키면 자기자신의 제곱근까지만 가도 된다.
이유는 임의의 a*b가 자기자신이 된다고 가정하자. 여기서 둘 중 하나는 무조건 자기자신의 제곱근보다 크다.
[∵만약 둘 다 자기자신의 제곱근보다 작거나 둘 다 크다고 가정하자.
그렇게 되면 둘의 곱은 무조건 자기자신보다 작거나 크게 되어서 앞의 조건인 둘의 곱이 자기자신이 된다는
조건과 모순이 된다.]
그러므로 1부터 자기자신의 제곱근까지만 찾게 되면 나머지 구간은 찾을 필요가 없다.

만약 100까지 중에서 소수를 구할 경우
원시적인 방법은 하나하나씩 대입하므로 시간이 길다[1~100까지]
1. 을 쓰면 반이상을 줄이게 된다[1~50까지]
2. 을 쓰면 1보다 훨씬 더 많이 줄어든다[1~10까지]

제곱근으로 소수 골라내는 알고리즘(예.13)
1. 나누를 수를 2부터 시작(1은 무조건 약수)
2. 2는 13의 제곱근보다 큰가?
3-1. 크면 소수 확정
3-2. 작으면 2는 13의 약수인가?
3-2-1. 맞으면 소수가 아니므로 다음 수로 넘어감(14)
3-2-2. 아니면 나누를 수를 1 더함(3), 2부터 다시 시작

        for (let i = 2; i <= 1000; i++) {
            for (let j = 1; (j * j < i); j) {
                if(i==2)
                {
                    document.write(`${i}는 소수입니다.<br>`);
                    break;
                }
                j++;
                if (j * j > i) {
                    document.write(`${i}는 소수입니다.<br>`);
                }
                else {
                    if (i % j == 0) {
                        document.write(`${i}는 소수가 아닙니다.<br>`);
                        break;

                    } else continue;
                }
            }
        }